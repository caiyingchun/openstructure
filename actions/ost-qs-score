"""Calculate Quaternary Structure score (QS-score) between two complexes."""

import os
import sys
import json
import argparse

import ost
from ost.io import (LoadPDB, LoadMMCIF, MMCifInfoBioUnit, MMCifInfo,
                    MMCifInfoTransOp)
from ost import PushVerbosityLevel
from ost.mol.alg import qsscoring


def _ParseArgs():
    """Parse command-line arguments."""
    parser = argparse.ArgumentParser(
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        description=__doc__,
        prog="ost qs-score")

    parser.add_argument(
        '-v',
        '--verbosity',
        type=int,
        default=3,
        help="Set verbosity level.")
    parser.add_argument(
        "-m",
        "--model",
        dest="model",
        required=True,
        help=("Path to the model file."))
    parser.add_argument(
        "-r",
        "--reference",
        dest="reference",
        required=True,
        help=("Path to the reference file."))
    parser.add_argument(
        "-c",
        "--chain-mapping",
        nargs="+",
        type=lambda x: x.split(":"),
        dest="chain_mapping",
        help=("Mapping of chains between the model and the reference. "
              "Each separate mapping consist of key:value pairs where key "
              "is the chain name in model and value is the chain name in "
              "reference."))
    parser.add_argument(
        "-o",
        "--output",
        dest="output",
        help=("Output file name. The output will be saved as a JSON file."))

    opts = parser.parse_args()
    if opts.chain_mapping is not None:
        try:
            opts.chain_mapping = dict(opts.chain_mapping)
        except ValueError:
            raise ValueError("Cannot parse chain mapping into dictionary. The "
                             "correct format is: key:value.")

    return opts


def _ReadStructureFile(path):
    """Safely read structure file into OST entity.

    The functin can read both PDB and mmCIF files.

    :param path: Path to the file.
    :type path: :class:`str`
    :returns: Entity
    :rtype: :class:`~ost.mol.EntityHandle`
    """
    entities = list()
    if not os.path.isfile(path):
        raise IOError("%s is not a file" % path)
    try:
        entity = LoadPDB(path)
        if not entity.IsValid():
            raise IOError("Provided file does not contain valid entity.")
        entity.SetName(os.path.basename(path))
        entities.append(entity)
    except Exception:
        try:
            tmp_entity, cif_info = LoadMMCIF(path, info=True)
            if len(cif_info.biounits) == 0:
                tbu = MMCifInfoBioUnit()
                tbu.id = 'ASU of ' + entity.pdb_id
                tbu.details = 'asymmetric unit'
                for chain in tmp_entity.chains:
                    tbu.AddChain(str(chain))
                tinfo = MMCifInfo()
                tops = MMCifInfoTransOp()
                tinfo.AddOperation(tops)
                tbu.AddOperations(tinfo.GetOperations())
                entity = tbu.PDBize(tmp_entity, min_polymer_size=0)
                entity.SetName(os.path.basename(path) + ".au")
                entities.append(entity)
            elif len(cif_info.biounits) > 1:
                for i, biounit in enumerate(cif_info.biounits):
                    entity = biounit.PDBize(tmp_entity, min_polymer_size=0)
                    if not entity.IsValid():
                        raise IOError(
                            "Provided file does not contain valid entity.")
                    entity.SetName(os.path.basename(path) + "." + str(i))
                    entities.append(entity)
            else:
                biounit = cif_info.biounits[0]
                entity = biounit.PDBize(tmp_entity, min_polymer_size=0)
                if not entity.IsValid():
                    raise IOError(
                        "Provided file does not contain valid entity.")
                entity.SetName(os.path.basename(path))
                entities.append(entity)

        except Exception as exc:
            raise exc
    return entities


def _Main():
    """Do the magic."""

    opts = _ParseArgs()
    PushVerbosityLevel(opts.verbosity)
    #
    # Read the input files
    ost.LogInfo("Reading model from %s" % opts.model)
    models = _ReadStructureFile(opts.model)
    ost.LogInfo("Reading reference from %s" % opts.reference)
    references = _ReadStructureFile(opts.reference)

    if len(models) > 1 or len(references) > 1:
        ost.LogInfo(
            "Multiple complexes detected. All combinations will be tried.")

    result = {"result": []}
    #
    # Perform scoring
    for model in models:
        for reference in references:
            ost.LogInfo("#\nComparing %s to %s" % (
                model.GetName(),
                reference.GetName()))
            try:
                qs_scorer = qsscoring.QSscorer(reference,
                                               model)
                if opts.chain_mapping is not None:
                    ost.LogInfo(
                        "Using custom chain mapping: %s" % str(
                            opts.chain_mapping))
                    qs_scorer.chain_mapping = opts.chain_mapping
                result["result"].append({
                    "status": "SUCCESS",
                    "error": "",
                    "model_name": model.GetName(),
                    "reference_name": reference.GetName(),
                    "global_score": qs_scorer.global_score,
                    "oligo_lddt_score": qs_scorer.lddt_score,
                    "best_score": qs_scorer.best_score,
                    "chain_mapping": qs_scorer.chain_mapping
                })
            except qsscoring.QSscoreError as ex:
                # default handling: report failure and set score to 0
                ost.LogError('QSscore failed:', str(ex))
                result["result"].append({
                    "status": "FAILURE",
                    "error": str(ex),
                    "model_name": model.GetName(),
                    "reference_name": reference.GetName(),
                    "global_score": 0.0,
                    "oligo_lddt_score": 0.0,
                    "best_score": 0.0,
                    "chain_mapping": None
                })
    if opts.output is not None:
        with open(opts.output, "w") as outfile:
            outfile.write(json.dumps(result, indent=4))


if __name__ == '__main__':
    # make script 'hot'
    unbuffered = os.fdopen(sys.stdout.fileno(), 'w', 0)
    sys.stdout = unbuffered
    _Main()
