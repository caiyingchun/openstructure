title: Data Algorithms - An Algorithm Tutorial
 
[TOC]

# Data Algorithms - An Algorithm Tutorial

This tutorial shows how to create custom high level dox[ost::iplt::ImageHandle|ImageHandle] algorithms and
embed them into the OpenStructure build system. As an example, two very simple algorithm will be written:
The first will count all values in an image or function that are larger than a certain threshold. Since this
algorithm only needs to read values, it will be implemented by deriving it from ConstAlgorithm. The second algorithm
will set all values below a certain threshold to the threshold value; this will be implemented
using ModIPAlgorithm.

Naming is important. We need a name for the collection (or module) of algorithms, as well as
a name for each individual one within the collection. For this example, the module name is
'thres', the first algorithm will be called 'ThresCount', and the second one 'ThresSet'.

The new module will be built following the guidelines on [this page](docs/tut/newmodule.html).
The information on the linked page will not be repeated here, so it advisable to read it before
continuing with this tutorial 

In the end, this algorithm module will consist of:

* Two header files, which are staged under 'stage/include/ost/thres' to allow other
components (such as the unit-tests, the python module, or other algorithms) to utilize
the module.
* A shared library called 'libost_thres', which is staged in 'stage/lib' and
required at run-time.
* A shared Python object named '_thres.so', which is staged under
'stage/lib/ost/pymod/ost/thres'.
* A Python initialization file '\_\_init\_\_.py', which is also staged under
'/lib/ost/pymod/ost/thres' and is required for the directory 'thres' to be recognized as a
 Python module.


## Algorithm Test Setup

Surprising or irritating as it may seem, the first thing on the agenda is the unit
test for this algorithm, located under 'thres/tests';.

Note 
:   Tests, and in this particular case unit-test, are an essential component of any
modern software development effort. They not only ascertain the continued correct
functionality after refactoring cycles or platform porting, they often consist
in the first step of writing new code: First you write the test, then you
implement the functionality. Sounds crazy? Really works! You can call that
developing in expectancy mode.

### Preparing the Testing Framework

The main testing code is put into 'tests.cc', there is nothing particular to discuss here:
    
    :::cpp
    #include <boost/test/unit_test.hpp>
    using boost::unit_test_framework::test_suite;

    #include "test_thres_count.hh"
    #include "test_thres_set.hh"

    test_suite*
    unit_unit_test_suite( int argc, char * argv[] ) {
      std::auto_ptr<test_suite> test(BOOST_TEST_SUITE( "Module thres Test" ));

      test->add(CreateThresCountTest()); 
      test->add(CreateThresSetTest()); 

      return test.release(); 
    }

        
The factory function declaration for the counting algorithm is put into 'test\_thres\_count.hh':

    :::cpp
    #ifndef OST_THRES_TEST_COUNT_H
    #define OST_THRES_TEST_COUNT_H

    #include <boost/test/unit_test.hpp>
    using boost::unit_test_framework::test_suite;

    test_suite* CreateThresCountTest();

    #endif
    
And the one for the threshold setting algorithm is put into 'test\_thres\_set.hh':

    :::cpp
    #ifndef OST_THRES_TEST_SET_H
    #define OST_THRES_TEST_SET_H

    #include <boost/test/unit_test.hpp>
    using boost::unit_test_framework::test_suite;

    test_suite* CreateThresSetTest();

    #endif


## Writitng the UnitTests

Now lets fill in the actual algorithm usage code. First, the declaration of the
algorithm needs to be included from its header. These are the two 'include'
statements we want to add, along with the 'namespace' code:

    :::cpp
    #include <ost/iplt/image.hh>
    #include <ost/thres/thres_count.hh>

    using namespace ost::iplt;
    using namespace ost::thres;
    
    
The first 'include' line and the 'ost::iplt' 'namespace' directive are needed
for creating and handling an ImageHandle. They use elements which are part of
the standard OpensStructure distribution. The others lines are required for our
particular algorithm class.

Note
:   Neither the file 'thres\_count.hh' exists yet nor the namespace 'thres'.
Remember, this is coding in expectency mode, ie we expect the algorithm to be
used in this way.

Next, the testing routine. As a first thing, an image needs
to be created, with which the functionality of the algorithm can be tested:

    :::cpp
    ImageHandle ih = CreateImage(Extent((Size(4,4))));

The factory method CreateImage() from the standard OpenStructure
distribution takes care of this. The dox[ost::iplt::ImageHandle|ImageHandle]
'ih' now referes to a 4x4 real, spatial image, with all values set to zero. To
populate the image with values, the following code is used:

    :::cpp
    double v=0.0;
    for(ExtentIterator(ih.GetExtent()); !it.AtEnd(); ++it) {
      ih.SetReal(it, v);
      v+=1.0;
    }

Now the algorithm object of our ThresCount class is created.

    ThresCount thres_count(5.0);

Note
:   Again, this is in expectancy mode: We want to have an algorithm that uses a
threshold, and it makes only sense that this threshold is given upon instantiation;
we will need to remember this once we implement the constructor.
As the next step, the algorithm is applied to the image, using the appropriate
method from dox[ost::iplt::ImageHandle|ImageHandle]:

    :::cpp 
    ih.Apply(a);

Finally the test: since the values in the image were consecutively set from 0.0
to 15.0, what is the expected outcome of the algorithm? In the above description,
it says "counts all values larger than a given threshold". In this case particular
test case this means all values above 5.0, so the expected count is 10.

To retrieve the count, the algorithm object requires some sort of getter method,
which we expect to be called 'GetCount()'. This is combined with the 'boost::test'
facility macro to see if the algorithm worked:

    :::cpp
    BOOST_CHECK(a.GetCount()==10);

That's it.

Here is the finished file 'test\_thres\_count.cc'.

    :::cpp
    #include "test_thres_count.hh"

    #include <ost/iplt/image.hh>
    #include <ost/thres_count.hh>
    using namespace ost::iplt;
    using namespace ost::thres;

    namespace test_thres_count {

      void test() 
      {
        ImageHandle ih = CreateImage(Extent((Size(4,4))));

        double v=0.0;
        for(ExtentIterator it(ih.GetExtent()); !it.AtEnd(); ++it) {
          ih.SetReal(it, v);
          v+=1.0;
        }
      ThresCount thres_count(5.0);

      ih.Apply(thres_count);

      BOOST_CHECK(thres_count.GetCount()==10);
      }

    }

    test_suite* CreateThresCountTest()
    {
      using namespace test_thres_count;
      test_suite* ts=BOOST_TEST_SUITE("ThresCount Test");

      ts->add(BOOST_TEST_CASE(&test));

      return ts;
    }

The test for 'ThresSet' algorithm is build in a similar way. A test image is setup, and the
initialization of the algorithm should also accept the threshold value to be used:

    :::cpp
    ImageHandle ih = CreateImage(Extent((Size(4,4))));

    double v=0.0;
    for(ExtentIterator it(ih.GetExtent()); !it.AtEnd(); ++it) {
      ih.SetReal(it, v);
      v+=1.0;
    }

    ThresCount thres_set(5.0);

    ih.ApplyIP(thres_set);
  
Note
:   There are two posibilities to apply this algorithm to the image: in-place
(used here) and out-of-place. This works even though the ThresSet algorithm itself
is implemented in-place. What is the expected outcome of applying the algorithm?
The description above said: "will set all values below a certain threshold to
the threshold value". Therefore there should not be a value below 5.0 in the image:

    :::cpp
    for(ExtentIterator it(ih.GetExtent()); !it.AtEnd(); ++it) {
      BOOST_CHECK(ih.GetReal(it)>=5.0);
    }

Here is the final test file 'test\_thres\_set'.cc:

    :::cpp
    #include "test_thres_set.hh"

    #include <ost/iplt/image.hh>
    #include <ost/thres/thres_set.hh>
    using namespace ost::iplt;
    using namespace ost::thres;

    namespace test_thres_set {

      void test() 
      {
        ImageHandle ih = CreateImage(Extent((Size(4,4))));

        double v=0.0;
        for(ExtentIterator it(ih.GetExtent()); !it.AtEnd(); ++it) {
          ih.SetReal(it, v);
          v+=1.0;
        }

        ThresSet thres_set(5.0);

        ih.ApplyIP(thres_set);

        for(ExtentIterator it(ih.GetExtent()); !it.AtEnd(); ++it) {
          BOOST_CHECK(ih.GetReal(it)>=5.0);
        }
      }
    }

    test_suite* CreateThresSetTest()
    {
      using namespace test_thres_set;
      test_suite* ts=BOOST_TEST_SUITE("ThresSet Test");

      ts->add(BOOST_TEST_CASE(&test));

      return ts;
    }

Obviously, all files need to be added to the 'CMakeLists.txt' file in 'thres/tests.'
Also, all the module dependencies must be added. In our example the dependencies are
the 'ost\_iplt' and 'ost\_iplt\_alg' module, plus the 'ost\_thres' moudle itself.

## Coding Algorithm

After so much expecting and looking into the future, this is the part where the
actual algorithm gets implemented. The CMake building script will also be setup to place the
headers and library files at the right location, so thay they are found by the unit tests.

In the 'thes/src' directory, let's add the header and source files for the two algorithms.

Here is 'thres\_count.hh:

    :::cpp 
    #ifndef OST_TRES_THRES_COUNT_H
    #define OST_TRES_THRES_COUNT_H

    #include <ost/iplt/algorithm.hh>
  
    namespace ost { namespace thres {

      class ThresCount: public NonModAlgorithm
      {
       public:
        ThresCount(Real thres);

        // retrieve count
        int GetCount() const;

        // algorithm interface
        virtual void Visit(const ConstImageHandle& i);
        virtual void Visit(const Function& f);

       protected:
        void VisitData(const Data& d);

       private:
        Real thres_;
       int count_;
      };

    }} // namespaces

    #endif

And here is 'thres\_count.cc':

    :::cpp
    #include "thres_count.hh"

    using namespace ost::iplt;
    using namespace ost::thres;

    ThresCount::ThresCount(Real thres):
      NonModAlgorithm("ThresCount"),
      thres_(thres),
      count_(0)
    {}

    void ThresCount::Visit(const ConstImageHandle& i)
    {
      // reroute to generic method
      VisitData(i);
    }
 
    void ThresCount::Visit(const Function& f)
    {
      // reroute to generic method
      VisitData(f);
    }

    void ThresCount::VisitData(const Data& d)
    {
      count_=0; // make sure count is reset for each visit
      for(ExtentIterator it(d.GetExtent()); !it.AtEnd(); ++it) {
        if(d.GetReal(it)>thres_) {
          ++count_;
        }
      }
    }

    int ThresCount::GetCount() const
    {
      return count_;
    }

Note
:   The polymorphic separation into  'dox[ost::iplt::ConstImageHandle|ConstImageHandle]' and
'Function' is not utilized in this example, since both 'Visit()' methods just call
'VisitData()' to perform the actual calculation. The method body of 'VisitData()'
is the actual algorithm implementation, using the private member variables 'thres\_'
and 'count\_'.

Here is the 'thres\_set.hh' file:

    :::cpp  
    #ifndef OST_THRES_THRES_SET_H
    #define OST_THRES_THRES_SET_H

    #include <ost/iplt/algorithm.hh>

    namespace ost { namespace thres {

      class ThresSet: public ModIPAlgorithm
      {
       public:
        ThresSet(Real thres);

        // algorithm interface
        virtual void Visit(ImageHandle& i);

       private:
        Real thres_;
      };

    }} // namespaces

    #endif


And here is 'thres_set.cc':

    :::cpp
    #include "thres_set.hh"

    using namespace ost::iplt;
    using namespace ost::thres;

    ThresSet::ThresSet(Real thres):
     ModIPAlgorithm("ThresSet"),
     thres_(thres)
    {}

    void ThresSet::Visit(ImageHandle& i)
    {
      for(ExtentIterator it(i.GetExtent()); !it.AtEnd(); ++it) {
        if(i.GetReal(it)<thres_) {
          i.SetReal(it,thres_);
        }
      }
    }

Once again, all the files must be added to the 'CMakeLists.txt' file, this time in
'thres/src'. This will make sure that all the headers and the newly created shared libraries
are staged correctly. The 'DEPENDS ON' directive in the file should include the 'iplt'
and 'iplt_alg' modules, since those are the modules 'thres' depends on.

## Python Wrapper

Finally, let's export both both 'ThresCount' and 'ThresSet' to Python, as part of
the 'thres' module. Let's put the following 'wrap\_thres.cc' file in the 'src/pymod' directory 

    :::cpp
    #include <boost/python.hpp>
    using namespace boost::python;

    #include <ost/thres/thres_count.hh>
    #include <ost/thres/thres_set.hh>

    using namespace ost::iplt;
    using namespace ost::thres;

    BOOST_PYTHON_MODULE(_tres)
    {
      class_<ThresCount, bases<NonModAlgorithm> >("ThresCount", init<Real>() )
        .def("GetCount", &ThresCount::GetCount)
      ;
  
      class_<ThresSet, bases<ModIPAlgorithm> >("ThresSet", init<Real>() )
      ;
    }

After adding the 'wrap_thres.cc' file to the 'CMakeLists.txt' file in 'thres/pymod, let's also put the
following '\_\_init.py\_\_' file in the same directory:

    :::python
    from _thres import *
 
The next time that the OpenStructure project will be compiled, the headers, the shared libraries and
the python modules from the new 'thres' module wil be staged and the two new Image algorithms will be made available
in both Python and C++.
    
    





