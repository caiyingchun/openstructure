title: Introduction to OpenStructure

[TOC]

# A gentle introduction to OpenStructure

In this tutorial you will be learning by example how to use the OpenStructure framework. 

We assume that you already have a version of OpenStructure installed. If not, please refer to the [installation instructions](download.html).

## What will be covered in this tutorial?

This tutorial is aimed at users that would like to get their hands dirty and execute commands in Python and write scripts rather clicking their way through a shiny user interface. The user interface of OpenStructure is in a very early state anyway that you probably won't go far by clicking you way through...

The first part of the tutorial is a walk-through of the basic functionality you will be using in your everyday work. You will learn how to load structure datasets, inspect, display them in the 3D window and save them. 


## Getting ready to rumble

The files we will be using in the tutorial are available in the examples folder that comes with OpenStructure. Depending on your platform, the examples are located at a different location:

 * on *MacOS X* the files are in /Applications/OpenStructure/Examples
 * on *Linux* and *Windows* PREFIX/share/openstructure/examples, where PREFIX is the path to the directory containing OpenStructure.

### Starting DNG

The graphical user interface of OpenStructure is called DNG (Dino/DeepView Next Generation). To start it, 

 * on *MacOS X* double click DNG.app in /Applications/OpenStructure
 * on *Windows* double click dng.bat inside the PREFIX/bin directory
 * on *Linux* fire up a terminal change into the OpenStructure installation directory and type 'bin/dng'. If you have the binary directory in the PATH, typing dng is sufficient.

### Interactive Python Shell
Now we will enter commands in the [python shell](docs/tut/pythonshell.html) (in the screenshot above, the python shell is located at the bottom of the main window). If you want to get more information on any object, function or class, the python help command may be useful. For example:

    ::::python
    # get list of methods of EntityView
    help(EntityView)
    # get help for method Select
    help(EntityView.Select)
    
## Loading and inspecting a protein structure

OpenStructure has a module that is dedicated to deal with input and output of data, including sequence alignment formats, protein structures and density data and images.  If you are reading this tutorial you most certainly have dealt with protein structures before and you are most certainly aware that they are usually stored in Brookhaven structure files (aka PDB files). The official name for molecules stored in a PDB file is an entity. You will hear this word throughout this tutorial, but you can replace the word entity with molecule in your head.

Before using the load functionality, you have to import the io module. This is done by typing the following command in the [python shell](docs/tut/pythonshell.html):

     ::::python
     from ost import io
To load a PDB file, type

     ::::python
     fragment=io.LoadPDB('OST_INSTALLATION_PATH/share/openstructure/examples/misc/fragment.pdb')
This will load the fragment from the specified file 'fragment.pdb' and store the result in fragment. For more information on the LoadPDB function, type

     ::::python
     help(io.LoadPDB)
Now let's inspect what we just loaded:

     ::::python
     print fragment.chain_count
     print fragment.residue_count
     print fragment.atom_count

As you can see, our fragment consists of one peptide chain of 12 amino acids and has 81 atoms in total. Now let's examine our fragment even further. Enter the command

     ::::python
     for residue in fragment.residues:
       print residue  
This will print a list of all residues in the fragment. Similarly to get a list of atoms, use:

    ::::python
    for atom in fragment.atoms:
      print atom

Of course, we can also get a list of atoms grouped by residues:
    
    ::::python
    for residue in fragment.residues:
      print residue, 'has', residue.atom_count, 'atom(s).'
      for atom in residue.atoms:
        print ' ', atom.name, atom.pos

And, for completeness, we will first group them by chain, then by residues.

    ::::python
    for chain in fragments.chains:
      print 'chain', chain.name, 'has', chain.residue_count, 'residue(s)'
      for residue in chain.residues:
        print ' ', residue, 'has', residue.atom_count, 'atom(s).'
        for atom in residue.atoms:
          print '    ', atom.name, atom.pos
Aah, wait! A protein fragment would not be complete without bonds: Let's see what bonds we have in there:

    ::::python
    for bond in fragment.bonds:
      print bond
From these short code examples we already see how the entity is structured: On one hand we have a hierarchy of chains, residues and atoms. On the other hand, we have bonds that form a network overlayed on the hierarchy. This is illustrated in the picture on the left. An important feature of entities is that we can always assume that the hierarchy is intact. You will never find an atom without residues, no residue can exist without a parent chain and chains belong always to an entity. 

## Let There Be Shiny Graphics

For visually inspecting the fragment, we now create a graphical representation:

     ::::python
     go=gfx.Entity("Fragment", fragment)
     scene.Add(go)
     scene.CenterOn(go)

Now you will see the fragment in the 3D window (left):

![](docs/tut/sel.png)

Use the mouse to rotate, zoom in an shift the camera. Double clicking on an atom will center the camera on that atom. 

## Introduction to Views

Often during processing and visualisation of data, only parts of a protein structure are of interest. This realisation has had a major impact on the design of OpenStructure and is tied very deeply into the core of the framework. Subparts of structure are modeled as so-called dox[ost::mol::EntityView|EntityViews]. You can think of them as a selection of chains, residues, atoms and bonds of an entity. A views has almost the same interface as the underlying entity, making it very easy to mix entity views with handles in Python due to the dynamic nature of the language. An algorithm that is written for entities will almost always (with some care) also work for dox[ost::mol::EntityHandle|EntityHandles]. This is referred to as [duck-typing](http://en.wikipedia.org/wiki/Duck_typing) (I don' t care if it is a duck as long as it looks like a duck), a concept used all over the place in Python. 
￼
A typical view can be seen in the image on the left. The view consists of one chain, one residue and two atoms. Again the same rule applies: No atom can be part of the view without it's residue. In this example, no bonds are included, since there is at most one atom per bond in the original structure.

To familiarize yourself with the concept of views, we will use the fragment in the 3D window.

We will use several ways to select parts of our fragment:
 * By using a dedicated query language
 * By manually constructing a view

## The Query Language

The first way to select parts of a structure is with a dedicated mini-language, called ["the query language”](docs/tut/query.html). In the Python Shell, type

    ::::python
    go.selection=fragment.Select('')
A green halo will be displayed around the selected parts (image in the middle).

 As you can see the previous statement created a “full view”, containing all the chains, residues, atoms and bonds. To select lysine residues, type

    ::::python
    go.selection=fragment.Select('rname=LYS')
    

As you can see (image in the middle), the  only lysine residue is now highlighted in the 3D window, because it was the only one matching the predicate “residue name must be equal to LYS”. Several such predicates can be combined with boolean operators such as “and” and “or”. To select residues with residue number 1 to 3, the following statement will do the job:

    ::::python
    go.selection=fragment.Select('rnum>=1 and rnum<=3')
but this is very cumbersome. That's why there is a shortcut to this statement. You can specify a range of values.

    ::::python
    go.selection=fragment.Select('rnum=1:3')
For a complete description of what you can do with the query language, have a look at the [query language introduction](docs/tut/query.html) or at the [reference page](dox/html/query.html).


## Constructing Views Manually

Sometimes the query language Is Not Enough (TM). For these cases the construction of manual entities becomes neccessary. This is pretty straight forward:

    ::::python
    view=fragment.CreateEmptyView()
    ca=fragment.FindAtom('A', mol.ResNum(1), 'CA')
    cb=fragment.FindAtom('A', mol.ResNum(1), 'CB')
    view.AddAtom(ca)
    view.AddAtom(cb)
    go.SetSelection(view)

The last step sets our constructed view as the current selection, displaying it in the 3D window. As you can see, C-alpha and C-beta of the first residue are not connected by bonds, even though both atoms are in the view. You have either to add the bond manually with

    ::::python
    ca_cb=ca.FindBondToAtom(cb)
    view.AddBond(ca_cb)
    
Or as a very convenient shortcut 'view.AddAllInclusiveBonds()' to add all bonds that have both bonding partners in the view.

Don't forget to call update the selection of the graphics object to see what view you have created.

## Saving an Entity

Saving an entity (or a view) is a breeze:

Type

     ::::python
     io.SavePDB(fragment, 'full.pdb')
to save the full view. To save only the backbone atoms, we can first select the backbone atoms and then save it:

     ::::python
     io.SavePDB(fragment.Select('aname=CA,C,N,O'), 'backbone.pdb')

