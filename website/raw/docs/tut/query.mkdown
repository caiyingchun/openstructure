[TOC]

# Queries


## The Basics

It is often convenient to highlight or focus certain parts of the structure. 
OpenStructure includes a powerful query system that allows you to perform custom 
selections in a convenient way.
Selections are carried out mainly by calling the Select method made available by EntityHandle and EntityView objects while providing a query string. Queries are written using a dedicated mini-language. For example, to select all arginine residues of a given structure, one would write:

    ::::python
    arginines=model.Select('rname=ARG')    
A simple selection query (called a predicate) consists in a property (here, `rname`), a comparison operator (here, `=`) and an argument (here, `ARG`).  The return value of a Select method is always an EntityView. The EntityView always contains a full hierarchy of elements, never standalone separated elements. In the above example, the EntityView called `arginines` will contain all chains from the structure called 'model' that have at least one arginine. In turn these chains will contain all residues that have been identified as arginines. The residues themselves will contain references to all of their atoms. Of course, queries are not limited to selecting residues based on their type, it is also possible to select atom by name:

    ::::python
    c_betas=model.Select('aname=CB') 
As before, c`betas is an instance of an EntityView object and contains a full hierarchy. The main difference to the previous example is that the selected residues do not contain a list of all of their atoms but only the C-beta. These examples clarify why the name 'view' was chosen for this result of a Select statement. It represents a reduced, restrained way of looking at the original structure.

Both the selection statements that have been used so far take strings as their arguments. However, selection properties such as `rnum` (residue number), take numeric arguments. With numeric arguments it is possible to use identity operators ( `!=` and `=`). It is also possible to compare them using the `>`, `<`, `>=` and `<=` operators. For example, the 20 N-terminal residues of a protein can be selected with:

    ::::python
    n_term=model.Select('rnum<=20')
## Combining predicates

Selection predicates can be combined with boolean operators. For example , you might want to select all C atoms with crystallographic occupancy higher than 50. These atoms must match the predicate `ele=C` in addition to the predicate `occ>50`. In the query language this can be written as:

    ::::python
    model.Select('ele=C and occ>50')
Compact forms are available for several selection statements. For example, to select all arginines and aspargines, one could use a statement like:

    ::::python
    arg_and_asn=model.Select('rname=ARG or rname=ASN')

However, this is rather cumbersome as it requires the word `rname` to be typed  twice. Since the only difference between the two parts of the selection is the argument that follows  the word `rname`, the statement can also be written in an abbreviated form:

    ::::python
    arg_and_asn=model.Select('rname=ARG,ASN')
Another example: to select residues with numbers in the range 130 to 200, one could use the following statement

    ::::python
    center=model.Select('rnum>=130 and rnum<=200')
or alternatively use the much nicer syntax:

    ::::python
    center=model.Select('rnum=130:200')
This last statement is completely equivalent to the previous one. This syntax  can be used when the selection statement requires a range of integer values within a closed interval.

## Distance Queries


The query

    ::::python
    around_center=model.Select('5 <> {0,0,0}')
selects all chains, residues and atoms that lie with 5 Å to the origin of the reference system ({0,0,0}). The `<>` operator is called the ‘within’ operator. 
Instead of a point, the within statements can also be used to return a view containing all chains, residues and atoms within a radius of another selection statement applied to the same entity.  Square brackets are used to delimit the inner query statement. 

    ::::python
    around_hem=model.Select('5 <> [rname=HEM]')
    model.Select('5 <> [rname=HEM and ele=C] and rname!=HEM')

## Bonds and Queries

When an EntityView is generated by a selection, it includes by default only bonds for which both connected atoms  satisfy the query statement. This can be changed by passing the parameters `EXCLUSIVE_BONDS` or `NO_BONDS` when calling the Select method. `EXCLUSIVE_BONDS` adds bonds to the EntityView when at least one of the two atoms falls within the boundary of the selection. `NO_BONDS` suppresses the bond inclusion step completely. 

## Whole Residue Queries

If the parameter `MATCH_RESIDUES` is passed when the Select method is called, the resulting EntityView will include whole residues for which at least one atom satisfies the query. This means that if at least one atom in the residue  falls within the boundaries of the selection, all atoms of the residue will be included in the View.

## More Query Usage

The high level interface for queries are the Select methods of the 
EntityHandle and EntityView classes. By passing in a query string, a view
consisting of a subset of the elements is returned. 

Queries also offer a second interface: `IsAtomSelected()`, 
`IsResidueSelected()` and `IsChainSelected()` take an atom, residue or 
chain as their argument and return true or false, depending on whether the 
element fulfills the predicates.

Read more about queries in the [query language reference](dox/html/query.html)

## Special Topics

### Distance-based selections

Distance-based selections within a given atom position are supported by the ‘within’ operator (`<>`) . To select atoms within 5 Angstrom of the point `{1,2,3}`, one would write:
5 <> {1,2,3}To select atoms which lie at a distance further than 5 Angstrom one would use the negation operator: 

    not 5 <> {1,2,3}

### Compact forms

Instead of writing:
`aname=CA or aname=C or aname=O or aname=N` one can write: 

aname=CA,N,C,OFor integer value ranges, one can use the colon syntax. Instead of `rnum>=10 and rnum<=20` one can write `rnum=10:20`.


## Constructing views manually


Sometimes the query language is not enough. For these cases the construction of manual entities becomes neccessary. This is pretty straight forward. Starting off with an empty view, bonds, atoms, residues and chains can be added at will.

    ::::python
    view=ent.CreateEmptyView()
To populate the entity view, use one of the EntityView.AddResidue(), EntityView.AddChain(), EntityView.AddAtom() and EntityView.AddBond() member functions:

    ::::python
    ca=ent.FindAtom('A', mol.ResNum(1), 'CA')
    view.AddAtom(ca)
This call will automatically insert the residue and the chain of the atom into the view, so `GetChainCount()`, `GetResidueCount()` and `GetAtomCount()` will all return 1.

To add a residue, use

    ::::python
    res=ent.FindResidue('A', mol.ResNum(1))
    view.AddResidue(res)
This will not add any atoms. To add the atoms, pass `mol.INCLUDE`ATOMS` to AddResidue:

    ::::python
    view.AddResidue(res, mol.INCLUDE_ATOMS)
Due to performance reasons, all of the add method do not check for duplicates by default. To turn duplicate-checking on, pass `mol.CHECK`DUPLICATES` as the second argument.
