

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Creating a New Module &mdash; OpenStructure v1.0 documentation</title>
    <link rel="stylesheet" href="_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="OpenStructure v1.0 documentation" href="index.html" />
    <link rel="next" title="Using External Programs within OpenStructure" href="external.html" />
    <link rel="prev" title="io - Input and Output of Sequences, Structures and Maps" href="io/io.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="external.html" title="Using External Programs within OpenStructure"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="io/io.html" title="io - Input and Output of Sequences, Structures and Maps"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">OpenStructure v1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Creating a New Module</a><ul>
<li><a class="reference internal" href="#directory-structure">Directory Structure</a></li>
<li><a class="reference internal" href="#the-module-code">The Module Code</a></li>
<li><a class="reference internal" href="#the-testing-framework">The Testing Framework</a></li>
<li><a class="reference internal" href="#the-python-wrapper">The Python Wrapper</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="io/io.html"
                        title="previous chapter"><tt class="docutils literal docutils literal docutils literal"><span class="pre">io</span></tt> - Input and Output of Sequences, Structures and Maps</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="external.html"
                        title="next chapter">Using External Programs within OpenStructure</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/newmodule.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="creating-a-new-module">
<h1>Creating a New Module<a class="headerlink" href="#creating-a-new-module" title="Permalink to this headline">¶</a></h1>
<p>OpenStructure can be extended by writing additional modules. A module will
usually consist of a set of C++ classes and methods, most of which will also be
exported to Python. It is also possible to write modules completely in Python.</p>
<p>The build system of OpenStructure is quite simple. The main difference to other
projects is the use of a so-called stage  directory. The stage directory
replicates the normal layout of a standard Linux directory structure, with an
&#8216;include&#8217; directory for the headers, a &#8216;lib&#8217; directory containing the shared
library files, a <cite>bin</cite> directory  for the executables and a &#8216;share&#8217; directory
for the platform-independent data like icons, images and examples.</p>
<p>OpenStructure uses <a class="reference external" href="http://www.cmake.org">CMake</a> to build the project. The
rules for the build-system are defined in <cite>CMakeLists.txt</cite> files. When running
<a class="reference external" href="http://cmake.org">CMake</a>, the files are  compiled and copied into stage. The
real installation, if necessary, happens at a later stage. This is referred to
as staging of the files.</p>
<p>If a new module is written following the guidelines in this page, it will be
seamlessly included in the build system and will then be available form both
the DNG python console and the OpenStructure command line as any other native
module.</p>
<p>As a first step, a new directory structure must be created to accommodate the
new module.</p>
<div class="section" id="directory-structure">
<h2>Directory Structure<a class="headerlink" href="#directory-structure" title="Permalink to this headline">¶</a></h2>
<p>For the purpose of this example, let&#8217;s assume we are creating a new module
called &#8216;mod&#8217; (for &#8216;modeling&#8217;). Let&#8217;s create a directory named <cite>mod</cite> under the
&#8216;modules&#8217; directory in the OpenStructure development tree, and  populate it with
the three subdirectories <cite>src</cite>, <cite>pymod</cite>, and <cite>tests</cite>.  Then we add a
<cite>CMakeLists.txt</cite> file in the &#8216;mod&#8217; directory, consisting of three lines:</p>
<div class="highlight-bash"><div class="highlight"><pre>add_subdirectory<span class="o">(</span>src<span class="o">)</span>
add_subdirectory<span class="o">(</span>pymod<span class="o">)</span>
add_subdirectory<span class="o">(</span>tests<span class="o">)</span>
</pre></div>
</div>
</div>
<div class="section" id="the-module-code">
<h2>The Module Code<a class="headerlink" href="#the-module-code" title="Permalink to this headline">¶</a></h2>
<p>In the <cite>src</cite> subdirectory we put the code that implements the functionality of
the new module, plus a <cite>config.hh</cite> header file.</p>
<p>Here is a skeleton of one of the files in  the directory , <cite>modeling_new_class.hh</cite>:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="cp">#ifndef OST_MOD_NEW_CLASS_H</span>
<span class="cp">#define OST_MOD_NEW_CLASS_H</span>

<span class="cp">#include &lt;ost/mod/module_config.hh&gt;</span>

<span class="c">// All other necessary includes go here</span>

<span class="k">namespace</span> <span class="n">ost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">mod</span> <span class="p">{</span>

<span class="k">class</span> <span class="nc">DLLEXPORT_OST_MOD</span> <span class="n">NewClass</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
   <span class="kt">void</span> <span class="n">NewMethod</span><span class="p">();</span>

  <span class="c">// All declarations of NewClass go here</span>

<span class="p">};</span>

<span class="p">}}</span> <span class="c">// namespaces</span>

<span class="cp">#endif</span>
</pre></div>
</div>
<p>And here is the skeleton of the corresponding <cite>modeling_new_class.cc</cite> file:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="cp">#include &quot;modeling_new_class.hh&quot;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">ost</span><span class="o">::</span><span class="n">mol</span><span class="p">;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">ost</span><span class="o">::</span><span class="n">mod</span><span class="p">;</span>

<span class="c">// All other necessary includes and namespace directives</span>
<span class="c">// go here</span>

<span class="kt">void</span> <span class="n">NewClass</span><span class="o">::</span><span class="n">NewMethod</span><span class="p">()</span><span class="o">:</span>
<span class="p">{</span>
  <span class="c">// Implementation</span>
<span class="p">}</span>

<span class="c">// Implementation code for NewClass goes here</span>
</pre></div>
</div>
<p>Obviously, the <cite>src</cite> directory can contain many files, each implementing classes
and functions that will end up in the module. In order to build and stage
the module shared library, a <cite>CMakeLists.txt</cite> file needs to be written for the
<cite>src</cite> directory:</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="nb">set</span><span class="o">(</span>OST_MOD_SOURCES
modeling_new_class.cc
// All other <span class="nb">source </span>files
<span class="o">)</span>

<span class="nb">set</span><span class="o">(</span>OST_MOD_HEADERS
modeling_new_class.hh
// All other header files
<span class="o">)</span>

 module<span class="o">(</span>NAME mod SOURCES <span class="s2">&quot;${OST_MOD_SOURCES}&quot;</span>
        HEADERS <span class="k">${</span><span class="nv">OST_MOD_HEADERS</span><span class="k">}</span>
        DEPENDS_ON mol mol_alg<span class="o">)</span>
</pre></div>
</div>
<p>The line containing the <cite>DEPENDS_ON</cite> directive lists all the modules on which
the new module depends (in this case <tt class="xref py py-mod docutils literal"><span class="pre">mol</span></tt> and <tt class="xref py py-mod docutils literal"><span class="pre">ost.mol.alg</span></tt>).  The
<cite>module</cite> macro will take care of staging the headers, in this case into
<cite>ost/mod</cite> and compiling, linking and staging of a library with the  name
<cite>libost_mod.so</cite> (<cite>libost_gmod.dylib</cite> on MacOS X).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Due to a limitation in the built-int install command of CMake, for modules
that have their headers in several directories, it is required to group the
headers by directory, leading to a call of module like:</p>
</div>
<div class="highlight-bash"><div class="highlight"><pre>module<span class="o">(</span>NAME mol SOURCES atom_handle.cc impl/atom_impl.cc
       HEADERS atom_impl.hh IN_DIR impl
       atom_handle.hh<span class="o">)</span>
</pre></div>
</div>
<p>The <cite>module_config.hh</cite> header is required for each module to setup the
environment on Windows: Each public class, method and function needs to marked
with <cite>DLLEXPORT</cite> or <cite>DLLIMPORT</cite> to teach the linker where to look for the
symbol. The correct use of either <cite>DLLIMPORT</cite> and <cite>DLLEXPORT</cite> is depending on
the context: While compiling a header file that is part of the same shared
library, <cite>DLLEXPORT</cite> must be used. When compiling a header that is part of
an external shared library, <cite>DLLIMPORT</cite> must be used. A typical module_config
header looks like this:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="cp">#ifndef OST_MOD_MODULE_CONFIG_HH</span>
<span class="cp">#define OST_MOD_MODULE_CONFIG_HH</span>

<span class="cp">#include &lt;ost/base.hh&gt;</span>

<span class="cp">#if defined(OST_MODULE_OST_MOD)</span>
<span class="cp">#  define DLLEXPORT_OST_MOD DLLEXPORT</span>
<span class="cp">#else</span>
<span class="cp">#  define DLLEXPORT_OST_MOD DLLIMPORT</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>
</pre></div>
</div>
</div>
<div class="section" id="the-testing-framework">
<h2>The Testing Framework<a class="headerlink" href="#the-testing-framework" title="Permalink to this headline">¶</a></h2>
<p>The <cite>tests</cite> directory contains code for unit tests. The code is compiled and
executed when one invokes compilation using the &#8216;make check&#8217; command.  Tests are
run by means of the <a class="reference external" href="http://www.boost.org/doc/libs/1_37_0/libs/test/doc/html/index.html">Boost Unitests Library</a>, which is
used throughout OpenStructure. Before coding the test routines, the required
skeleton needs to be put in place.</p>
<p>The main code is put into &#8216;tests.cc&#8217;, which will become the test executable:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="cp">#include &lt;boost/test/unit_test.hpp&gt;</span>
<span class="k">using</span> <span class="n">boost</span><span class="o">::</span><span class="n">unit_test_framework</span><span class="o">::</span><span class="n">test_suite</span><span class="p">;</span>

<span class="cp">#include &quot;test_modeling.hh&quot;</span>

<span class="n">test_suite</span><span class="o">*</span>
<span class="n">unit_unit_test_suite</span><span class="p">(</span> <span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[]</span> <span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">auto_ptr</span><span class="o">&lt;</span><span class="n">test_suite</span><span class="o">&gt;</span> <span class="n">test</span><span class="p">(</span><span class="n">BOOST_TEST_SUITE</span><span class="p">(</span> <span class="s">&quot;Module Mod Test&quot;</span> <span class="p">));</span>

  <span class="n">test</span><span class="o">-&gt;</span><span class="n">add</span><span class="p">(</span><span class="n">CreateModelingTest</span><span class="p">());</span>

  <span class="k">return</span> <span class="n">test</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The most relevant line adds the test suite for the new module to the global test
list. The test suite is created by the factory function CreateModelingTest(),
which is declared in the <cite>test_modeling.hh</cite> header file.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="cp">#ifndef OST_MOD_TEST_MODELING_H</span>
<span class="cp">#define OST_MOD_TEST_MODELING_H</span>

<span class="cp">#include &lt;boost/test/unit_test.hpp&gt;</span>
<span class="k">using</span> <span class="n">boost</span><span class="o">::</span><span class="n">unit_test_framework</span><span class="o">::</span><span class="n">test_suite</span><span class="p">;</span>

<span class="n">test_suite</span><span class="o">*</span> <span class="n">CreateModelingTest</span><span class="p">();</span>

<span class="cp">#endif</span>
</pre></div>
</div>
<p>The definition of the factory function is found in the actual test code,
which we put in <cite>test_modeling.cc</cite>. Here is a skeleton version of that file:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="cp">#include &quot;test_modeling.hh&quot;</span>

<span class="c">// additional include statements will go here</span>

<span class="k">namespace</span> <span class="n">test_modeling</span> <span class="p">{</span>

  <span class="kt">void</span> <span class="n">test</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="c">// test code will go here</span>
  <span class="p">}</span>

<span class="p">}</span>

<span class="n">test_suite</span><span class="o">*</span> <span class="n">CreateModelingTest</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">using</span> <span class="k">namespace</span> <span class="n">test_modeling</span><span class="p">;</span>
  <span class="n">test_suite</span><span class="o">*</span> <span class="n">ts</span><span class="o">=</span><span class="n">BOOST_TEST_SUITE</span><span class="p">(</span><span class="s">&quot;Modeling Test&quot;</span><span class="p">);</span>
   <span class="n">ts</span><span class="o">-&gt;</span><span class="n">add</span><span class="p">(</span><span class="n">BOOST_TEST_CASE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">test</span><span class="p">));</span>

   <span class="k">return</span> <span class="n">ts</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In this file, all the normal Boost Test Library macros and functions can be used. (For example <cite>BOOST_CHECK</cite>, <cite>BOOST_FAIL</cite>, etc.)</p>
<p>Here is finally the build script skeleton that needs to be put into
<cite>mod/tests/</cite>:</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="nb">set</span><span class="o">(</span>OST_MOD_UNIT_TESTS
tests.cc
test_modeling.cc
<span class="o">)</span>

ost_unittest<span class="o">(</span>mod <span class="s2">&quot;${OST_MOD_UNIT_TESTS}&quot;</span><span class="o">)</span>
target_link_libraries<span class="o">(</span>ost_mol ost_mol_alg ost_mod<span class="o">)</span>
</pre></div>
</div>
<p>In the last line the call to the &#8216;target_link_libraries&#8217; function contains the
names of the modules on which the &#8216;mod&#8217; unit test code depends (in this case,
the <tt class="xref py py-mod docutils literal"><span class="pre">mol</span></tt> and <tt class="xref py py-mod docutils literal"><span class="pre">ost.mol.alg</span></tt> modules), in addition to the <cite>mod</cite> module
itself.</p>
</div>
<div class="section" id="the-python-wrapper">
<h2>The Python Wrapper<a class="headerlink" href="#the-python-wrapper" title="Permalink to this headline">¶</a></h2>
<p>Finally, the module API is exported to Python using the <a class="reference external" href="http://www.boost.org/doc/libs/1_37_0/libs/python/doc/index.html">Boost Python
Library</a>.
In <cite>mod/pymod</cite>, the wrapper code for the classes in the new module is put into a
file named <cite>wrap_mod.cc</cite>:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="cp">#include &lt;boost/python.hpp&gt;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">boost</span><span class="o">::</span><span class="n">python</span><span class="p">;</span>

<span class="cp">#include &lt;ost/mod/modeling_new_class.hh&gt;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">ost</span><span class="o">::</span><span class="n">mol</span><span class="p">;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">ost</span><span class="o">::</span><span class="n">mod</span><span class="p">;</span>

<span class="c">// All other necessary includes and namespace directives</span>
<span class="c">// go here</span>

<span class="n">BOOST_PYTHON_MODULE</span><span class="p">(</span><span class="n">_mod</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">class_</span><span class="o">&lt;</span><span class="n">NewClass</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;NewClass&quot;</span><span class="p">,</span> <span class="n">init</span><span class="o">&lt;&gt;</span><span class="p">()</span> <span class="p">)</span>
    <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;NewMethod&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">NewClass</span><span class="o">::</span><span class="n">NewMethod</span><span class="p">)</span>
  <span class="p">;</span>

  <span class="c">// All other Boost Python code goes here</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <cite>mod/pymod</cite> directory must obviously contain a <cite>CMakeLists.txt</cite> file:</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="nb">set</span><span class="o">(</span>OST_MOD_PYMOD_SOURCES
wrap_mod.cc
<span class="o">)</span>

pymod<span class="o">(</span>NAME mod OUTPUT_DIR ost/mod
      CPP <span class="k">${</span><span class="nv">OST_MOD_PYMOD_SOURCES</span><span class="k">}</span> PY __init__.py<span class="o">)</span>
</pre></div>
</div>
<p>The directory should also contain an <cite>__init.py__</cite> file with the
following content:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">from</span> <span class="nn">_mod</span> <span class="k">import</span> <span class="o">*</span>
</pre></div>
</div>
<p>In case one wants to implement Python-only functionality for the new module, any
number of function definitions can be added to the <cite>__init.py__</cite> file.</p>
<p>That&#8217;s it!. The next time the OpenStructure project is compiled, the new module
will be built and made available at both the C++ and the Python level.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="external.html" title="Using External Programs within OpenStructure"
             >next</a> |</li>
        <li class="right" >
          <a href="io/io.html" title="io - Input and Output of Sequences, Structures and Maps"
             >previous</a> |</li>
        <li><a href="index.html">OpenStructure v1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2010, OpenStructure authors.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0b2.
    </div>
  </body>
</html>